use crate::data_access::{DAO, DAOCommande, DAOBurger, DAOFactory};
use crate::entity::{Commande, Boisson, Burger};
use mysql::{Row, from_row};
use mysql::prelude::Queryable;
use std::collections::HashMap;
use crate::data_access::dao_burger::fetch_ingredients;

/*
 * Tuple generated by datas from database
 * for table `burger`
 * - id
 * - n_table
 * - heure
 * - n_serveur
 * - paye
*/
type DataFromDb = (Option<u32>, Option<u8>, Option<String>, Option<u8>, Option<u8>);

/*
 * Tuple generated by datas from database
 * for table `boisson`
 * - id
 * - nom
 * - prix
 * - description
 * - calories
 * - qte stock
 * - qte min
 * - image
 * - quantite
*/
type BoissonFromDb = (Option<u32>, Option<String>, Option<f32>, Option<String>,
                   Option<u16>, Option<u8>, Option<u8>, Option<String>, Option<u8>);

/*
 * Tuple generated by datas from database
 * for table `burger`
 * - id
 * - nom
 * - prix
 * - description
 * - recette
 * - image
 * - quantite
*/
type BurgerFromDb = (Option<u32>, Option<String>, Option<f32>, Option<String>,
                   Option<String>, Option<String>, Option<u8>);

impl DAO<Commande> for DAOCommande
{
    fn create(&self, _obj: Commande) -> bool {
        false
    }

    fn update(&self, _obj: Commande) -> bool {
        false
    }

    fn delete(&self, _obj: Commande) -> bool {
        false
    }

    fn find_by_id(&mut self, id: u32) -> Commande
    {
        let query = "SELECT id, n_table, CAST(heure AS CHAR), n_serveur, paye \
                          FROM `commande` WHERE `id` = ?";
        let result: Row = self.conn.exec_first(query, (id,)).unwrap().unwrap();
        let datas = from_row::<DataFromDb>(result);
        let mut commande = Commande::new();
        commande.feed_from_db(datas);
        // Once the command has been retrieved, we fetch drinks
        commande.set_boissons(fetch_boissons(self, id));
        // Finally, we fetch burgers and their ingredients
        commande.set_burgers(fetch_burgers(self, id));

        commande
    }

    fn find_all(&mut self) -> Vec<Commande>
    {
        unimplemented!()
    }
}

impl DAOCommande
{
    pub fn get_id_from_datetime(&mut self, datetime: &str) -> u32
    {
        let query = "SELECT `id` FROM `commande` WHERE `heure` = ?";
        let result: Row = self.conn.exec_first(query, (datetime,)).unwrap().unwrap();
        let data = from_row::<(u32)>(result);

        data
    }
}

fn fetch_boissons(dao: &mut DAOCommande, commande_id: u32) -> Vec<Boisson>
{
    let query = "SELECT boisson.*, commande_boisson.quantite \
                      FROM commande_boisson \
                      INNER JOIN boisson \
                      ON commande_boisson.boisson_id = boisson.id \
                      WHERE commande_boisson.commande_id = ?";

    let result: Vec<Row> = dao.conn.exec(query, (commande_id,)).unwrap();
    let mut list_boissons = Vec::new();
    push_row_to_vec_boi(result, &mut list_boissons);

    list_boissons
}
fn push_row_to_vec_boi(result: Vec<Row>, list_boi: &mut Vec<Boisson>)
{
    for row in result
    {
        let datas = from_row::<BoissonFromDb>(row);
        let mut boisson = Boisson::new();
        // adding the quantity of each drinks to the boisson.quantite field
        boisson.set_quantite(datas.8.unwrap());
        boisson.feed_from_db(datas);
        list_boi.push(boisson);
    }
}

fn fetch_burgers(dao: &mut DAOCommande, commande_id: u32) -> Vec<Burger>
{
    let query = "SELECT burger.*, commande_burger.quantite \
                      FROM commande_burger \
                      INNER JOIN burger \
                      ON commande_burger.burger_id = burger.id \
                      WHERE commande_burger.commande_id = ?";

    let result: Vec<Row> = dao.conn.exec(query, (commande_id,)).unwrap();
    let mut list_burgers= Vec::new();
    push_row_to_vec_bur(result, &mut list_burgers);

    list_burgers
}
fn push_row_to_vec_bur(result: Vec<Row>, list_bur: &mut Vec<Burger>)
{
    for row in result
    {
        let datas = from_row::<BurgerFromDb>(row);
        let mut burger = Burger::new();
        // adding the quantity of each burgers to the burger.quantite field
        burger.set_quantite(datas.6.unwrap());
        burger.feed_from_db(datas);
        burger.set_ingredients(fetch_ingredients(&mut DAOFactory::create_dao_burger(), burger.get_id()));
        list_bur.push(burger);
    }
}
