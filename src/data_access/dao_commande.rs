use crate::data_access::{DAO, DAOCommande};
use crate::entity::{Commande, Boisson};
use mysql::{Row, from_row};
use mysql::prelude::Queryable;
use std::collections::HashMap;

/*
 * Tuple generated by datas from database
 * for table `burger`
 * - id
 * - n_table
 * - heure
 * - n_serveur
 * - paye
*/
type DataFromDb = (Option<u32>, Option<u8>, Option<String>, Option<u8>, Option<u8>);

/*
 * Tuple generated by datas from database
 * for table `boisson`
 * - id
 * - nom
 * - prix
 * - description
 * - calories
 * - qte stock
 * - qte min
 * - image
 * - quantite
*/
type BoissonFromDb = (Option<u32>, Option<String>, Option<f32>, Option<String>,
                   Option<u16>, Option<u8>, Option<u8>, Option<String>, Option<u8>);

impl DAO<Commande> for DAOCommande
{
    fn create(&self, _obj: Commande) -> bool {
        false
    }

    fn update(&self, _obj: Commande) -> bool {
        false
    }

    fn delete(&self, _obj: Commande) -> bool {
        false
    }

    fn find_by_id(&mut self, id: u32) -> Commande
    {
        let query = "SELECT id, n_table, CAST(heure AS CHAR), n_serveur, paye \
                          FROM `commande` WHERE `id` = ?";
        let result: Row = self.conn.exec_first(query, (id,)).unwrap().unwrap();
        let datas = from_row::<DataFromDb>(result);
        let mut commande = Commande::new();
        commande.feed_from_db(datas);
        // Once the command has been retrieved, we fetch drinks
        commande.set_boissons(fetch_boissons(self, id));
        // Finally, we fetch burgers and their ingredients

        commande
    }

    fn find_all(&mut self) -> Vec<Commande>
    {
        unimplemented!()
    }
}

impl DAOCommande
{
    pub fn get_id_from_datetime(&mut self, datetime: &str) -> u32
    {
        let query = "SELECT `id` FROM `commande` WHERE `heure` = ?";
        let result: Row = self.conn.exec_first(query, (datetime,)).unwrap().unwrap();
        let data = from_row::<(u32)>(result);

        data
    }
}

fn fetch_boissons(dao: &mut DAOCommande, commande_id: u32) -> Vec<Boisson>
{
    let query = "SELECT boisson.*, commande_boisson.quantite \
                      FROM commande_boisson \
                      INNER JOIN boisson \
                      ON commande_boisson.boisson_id = boisson.id \
                      WHERE commande_boisson.commande_id = ?";

    let result: Vec<Row> = dao.conn.exec(query, (commande_id,)).unwrap();
    let mut list_boissons = Vec::new();
    push_row_to_vec_boi(result, &mut list_boissons);

    list_boissons
}
fn push_row_to_vec_boi(result: Vec<Row>, list_boi: &mut Vec<Boisson>)
{
    for row in result
    {
        let datas = from_row::<BoissonFromDb>(row);
        let mut boisson = Boisson::new();
        // adding the quantity of each drinks to the boisson.quantite field
        boisson.set_quantite(datas.8.unwrap());
        boisson.feed_from_db(datas);
        list_boi.push(boisson);
    }
}
